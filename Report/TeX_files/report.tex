\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{physics}
\usepackage{mathtools}
\usepackage{comment}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}

\newcommand{\T}{\mathbb{T}}
\newcommand{\p}{\mathcal{P}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Hilb}{\mathcal{H}}
\newcommand{\Exp}{\mathbb{E}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\w}{\wedge}\usepackage{xcolor}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{braket}

\renewcommand\bra[1]{{\langle{#1}|}}
\makeatletter
\renewcommand\ket[1]{%
  \@ifnextchar\bra{\k@t{#1}\!}{\k@t{#1}}%
}
\newcommand\k@t[1]{{|{#1}\rangle}}
\makeatother

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Learning with Quantum Computers}


\author{\IEEEauthorblockN{Soham Joshi}
\IEEEauthorblockA{\textit{Computer Science and Engineering} \\
\textit{IIT Bombay (of Aff.)}\\
Mumbai, India \\
sohamjoshi@cse.iitb.ac.in}
}

\maketitle

\begin{abstract}
Quantum Computing (QC), is a developing field with counter-intuitive and surprising results.
Manipulating hidden information caused by the probabilistic nature of quantum information has
enabled researchers to formulate algorithms with lesser asymptotic time complexity\cite{b1}.
Moreover, the combination of hidden information and entanglement at the quantum level has led to 
the reformulation of several machine learning algorithms in the language of quantum computing\cite{b2}\cite{b5}\cite{b7}.
This survey presents some of the basic concepts needed to understand quantum computing and quantum information, 
and covers some of the machine learning algorithms which have been optimized due to this field.
\end{abstract}

\begin{IEEEkeywords}
Quantum Machine Learning, Quantum Computing, Quantum Information, QuGANs
\end{IEEEkeywords}

\section{Introduction}
This report is a part of the project, ``Machine Learning with Quantum Computers"\cite{b3}, under
the guidance of Siddhant Midha and Aditya Sriram. The project is a part of a program named ``Winter in Data Science'' (WiDS)
conducted by Analytics Club, IIT Bombay. In this paper, basic concepts of quantum computing and quantum information 
will be covered in a way that is accessible to the reader with a knowledge of basic linear algebra and some quantum mechanics.
In this report I will also survey some research papers pertaining to the fields of quantum machine learning (QML). Additionally 
the project includes implementation of quantum algorithms using qiskit and pennylane, the code for which can be found \href{https://github.com/Ihsoj-Mahos/WiDS-QML}{here}.
This paper is meant to be an overview of QC, so some parts of this paper may leave facts without proof. In such cases, kindly refer \cite{b2} for more details.
\section{Quantum bits}
The bit is the fundamental concept of classical computation and classical information. Quantum computation 
and quantum information are built upon an analogous concept, the quantum bit, or qubit for short. Note that 
a bit is just a mathematical entity, in physical circuits high/low voltages can be modelled by a bit taking value
1 or 0. Analogously a qubit is just another abstract mathematical entity. Does this mean that the qubit isn't ``real''?
Yes, a qubit is a tool used for modelling quantum mechanical systems. But studying the properties of the qubit is still 
worth our time since this helps us to develop a theory independent of physical constraints and which helps model reality 
to a good approximation.

\subsection{States of a qubit}
Just as a bit can take values 0, 1; a qubit can be in states $\ket{0}$, $\ket{1}$. Moreover, a qubit can be in a linear combination 
of these states given by : 

\begin{equation*}
    \ket{\psi} = \alpha\ket{0} + \beta\ket{1}
\end{equation*}
where $\alpha, \beta \in \C$. \\ 
The state of a qubit is a vector in a two-dimensional complex vector space. The special states $\ket{0}$ and $\ket{1}$ are known as 
the computational basis states \footnote{Measurement can be done with respect to a basis other than this. For instance, measurements can be done with respect to the basis $\ket{+} \equiv \frac{\ket{0} + \ket{1}}{\sqrt{2}}, \ket{-} \equiv \frac{\ket{0} - \ket{1}}{\sqrt{2}}$}, form an orthonormal basis for this vector space. 
But, what makes a qubit different from a bit? It is the fact 
that the coefficients of linear combination $\alpha$, $\beta$ cannot be measured. Quantum mechanics tells us that we can obtain much more restricted 
information about this state, particularly, upon measurement, we can obtain $\ket{0}$ with probability $|\alpha|^2$, and
$\ket{1}$ with probability $|\beta|^2$. Since the probabilites must sum to 1, the restriction $|\alpha|^2+|\beta|^2 = 1$ is imposed on the
coefficients of linear combination.

\subsection{Bloch sphere}
A tool which helps to visualise actions on a qubit is known as the \textit{Bloch sphere}. Because of the restriction imposed on $|\alpha|, |\beta|$, 
we can rewrite the state of a qubit as : 

\begin{equation*}
    \ket{\psi} = e^{i\gamma}\left(cos\frac{\theta}{2}\ket{0} + e^{i\varphi}sin\frac{\theta}{2}\ket{1}\right)
\end{equation*}
In the next section we will see that global phase factors have no effect so this can be re-written as : 
\begin{equation*}
    \ket{\psi} = cos\frac{\theta}{2}\ket{0} + e^{i\varphi}sin\frac{\theta}{2}\ket{1}
\end{equation*}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/bloch.png}}
\caption{Bloch sphere representation of a qubit}
\label{bloch}
\end{figure}

\subsection{Multiple qubits}
Suppose we have two qubits. If these were two classical bits, then there would be four
possible states, 00, 01, 10, and 11. Correspondingly, a two qubit system has four computational basis states 
\footnote{Another example of commonly used basis are called the ``bell states/EPR pairs'', given by $\ket{\beta_{00}} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}; \ket{\beta_{01}} = \frac{\ket{01} + \ket{10}}{\sqrt{2}}; \ket{\beta_{10}} = \frac{\ket{00} - \ket{11}}{\sqrt{2}}; \ket{\beta_{11}} = \frac{\ket{01} - \ket{10}}{\sqrt{2}}$}
denoted $\ket{00}, \ket{10}, \ket{10}, \ket{11}$. A pair of qubits can also exist in
superpositions of these four states,
\begin{equation*}
    \ket{\psi} = \alpha_{00}\ket{00} + \alpha_{01}\ket{01} + \alpha_{10}\ket{10} + \alpha_{11}\ket{11}
\end{equation*}
Similar to the case for a single qubit, the measurement result x (= 00, 01, 10 or 11) occurs
with probability $|\alpha_x|^2$ , with the state of the qubits after the measurement being $\ket{x}$.
More generally, we may consider a system of n qubits. The computational basis states
of this system are of the form $\ket{x_{1}x_{2}{}_{\cdots}x_{n}}$, and so a quantum state of such a system
is speciﬁed by $2^n$ amplitudes.

\section{Quantum Gates}
Classical gates are responsible for manipulating bits, essentially representing a boolean function from bits to bits.
Similarly, quantum gates are just a function from qubits to qubits. In this section, we shall explore the different classes of quantum gates. 
We will not delve into proofs but offer an operational description of how quantum gates work. Further details for this can be found in \ref{gates}
\subsection{Single-Qubit gates}
A qubit can be written as a $2 \times 1$ unit vector in the space spanned by $\ket{0}, \ket{1}$. So, a transformation from a single qubit to 
another qubit transforms a unit vector to another unit vector. Hence, it follows that all quantum gates are unitary. Moreover, it turns out that any 
unitary operation is a valid quantum gate and can be constructed from some ``universal'' quantum gates (will be discussed later).

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/single-gates.png}}
\caption{Single qubit gates}
\label{singlegate}
\end{figure}

Some single qubit quantum gates are shown in figure \ref{singlegate}. Since we are dealing with the qubit as an abstraction, a quantum gate is just a black box 
operator that performs a unitary transformation to a qubit. For now, we will not deal with the question of the physical realisation of these gates. 

\subsection{Multiple qubit gates}
In classical computation, there are five notable quantum gates, namely \verb|NOT|, \verb|AND|, \verb|OR|, \verb|NAND|, \verb|NOR|. As it turns out, 
all of these gates can be simulated using quantum gates as well. But, as a first step, consider the controlled-NOT, or the \verb|CNOT| gate (figure \ref{cnot}).
Now, we go into an important point when dealing with quantum gates. Even though the circuit diagram shows two input lines in the circuit, the \verb|CNOT| gate doesn't act on 
a single qubit, but a system of two ``entangled'' qubits. Hence, the only correct way to apply the circuit is to take the tensor product of the two input vectors, apply the gate and obtain 
another tensor product. The notation $\ket{a} \otimes \ket{b}$ is often abbreviated as $\ket{a}\ket{b}$ or $\ket{ab}$. So the action of a gate $U$ will be given as : 
\begin{equation*}
    \ket{a}\ket{b} \xrightarrow[]{U} U\ket{a}\ket{b}
\end{equation*}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.7]{Images/cnot.png}}
\caption{CNOT gate}
\label{cnot}
\end{figure}

Moreover, just because the control qubit does not change values when it is a computational basis state doesn't mean that it will remain the same for all vectors. In fact, 
the control qubit often changes and measuring it's state is a key step in several quantum algorithms. Another important fact is that 
any multiple qubit quantum gate can be constructed using \verb|CNOT| and single qubit quantum gates. Hence, they form a set of universal quantum gates.
So, the \verb|CNOT| gate is analogous to the \verb|XOR| gate, but not exactly equivalent. Can gates be constructed exactly equivalent to \verb|NAND|, \verb|XOR| gates? Turns out this is 
not possible because quantum gates must be reversible whereas \verb|XOR| and \verb|NAND| gates are irreversible, i.e., given the output of these gates, the input cannot be uniquely identified. 

\subsection{Quantum circuits}
We have already seen some quantum circuits, but let us examine quantum ciruits in some more detail. Each line in the circuit is represented by a wire, but this wire is not necessarily physical, 
it may as well represent the passage of time, or a physical particle such as a photon. There are a few features allowed in classical circuits that are not usually present in
quantum circuits. Loops in a circuit are not allowed, \verb|FANOUT| and \verb|FANIN| operations are not allowed. This is because of the ``no-cloning''\footnote{The no-cloning theorem states that ``qubit-copying'' is not permitted. Hence, junctions of wires are not permitted in a quantum circuit. The no-cloning theorem proves to be useful in quantum encryption protocols like BB84 \cite{b4}} theorem.
An example of a quantum circuit is the ``quantum teleportation circuit''(figure \ref{teleport}). The setting of the problem is that Alice and Bob met long ago but now live
far apart. While together they generated an EPR pair, each taking one qubit of the EPR pair when they separated. Alice now wants deliver a qubit $\ket{\psi}$ to Bob. She does not know the state of
the qubit, and moreover can only send classical information to Bob. This can be achieved using the circuit given. 

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/teleport.png}}
\caption{Quantum circuit for teleporting a qubit. The two top lines represent Alice's system, while the bottom
line is Bob's system. The meters represent measurement, and the double lines coming out of them carry classical
bits (recall that single lines denote qubits)}
\label{teleport}
\end{figure}

\subsection{The Deutsch-Jozsa algorithm}
The problem is as follows. Alice, selects a number $x$ from $0$ to $2^n - 1$, and mails it in a letter to Bob. Bob calculates some function
$f(x)$ and replies with the result, which is either 0 or 1. Now, Bob has promised to use
a function $f$ which is of one of two kinds; either $f(x)$ is constant for all values of $x$,
or else $f(x)$ is balanced, that is, equal to 1 for exactly half of all the possible $x$, and 0
for the other half. Alice's goal is to determine with certainty whether Bob has chosen a
constant or a balanced function, corresponding with him as little as possible. In order to solve this we use the algorithm described (figure \ref{dj-algo}). 
The circuit for the same is shown in figure \ref{dj-ckt}
\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/deutch-algo.png}}
\caption{Deutsch-Jozsa algorithm}
\label{dj-algo}
\end{figure}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/deutch-ckt.png}}
\caption{Deutsch-Jozsa algorithm's circuit}
\label{dj-ckt}
\end{figure}

Finally, if the measurement yields all 0s then the function is constant, otherwise balanced. The reader can try verifying this as an exercise.

\section{The postulates of quantum mechanics}
Quantum mechanics is a mathematical framework for the development of physical theories. Just as newton's laws are axioms for classical mechanics, 
the postulates of quantum mechanics are not ``derived'', but assumed. The motivations of these postulates(axioms) may not always be clear, since 
they have been guessed after a lot of experimentation. So, this part of the report aims at knowing the postulates and gaining an operational understanding of the same. 
Understanding these axioms will  help us realise what happens in physical systems, and not the abstract vectors we have been dealing with till now.

\subsection{State space}
\textbf{Postulate 1} : Associated to any isolated physical system is a complex vector space
with inner product (that is, a Hilbert space) known as the state space of the
system. The system is completely described by its \textit{state vector}, which is a unit
vector in the system's state space.

Quantum mechanics does \textit{not} tell us, for a given physical system, what the state space
of that system is, nor does it tell us what the state vector of the system is. Figuring that
out for a speciﬁc system is a difﬁcult problem for which physicists have developed many
intricate and beautiful rules. We will take the qubit as our fundamental quantum mechanical system.

\subsection{Evolution} \label{post2}
\textbf{Postulate 2} : The evolution of a \textit{closed} quantum system is described by a unitary
transformation. That is, the state $\ket{\psi}$ of the system at time $t_1$ is related to the
state $\ket{\psi}$ of the system at time $t_2$ by a unitary operator $U$ which depends only on
the times $t_1$ and $t_2$,
\begin{equation*}
    \ket{\psi^{'}} = U\ket{\psi}
\end{equation*}
Just as quantum mechanics does not tell us the state space or quantum state of a
particular quantum system, it does not tell us which unitary operators U describe real-world quantum dynamics. Quantum mechanics merely assures us that the evolution of
any closed quantum system may be described in such a way. Another interesting result follows from this postulate. If $t_1$
and $t_2$ are ``close'', then we can talk about derivative of functions, 

\textbf{Postulate 2'} : The time evolution of the state of a closed quantum system is
described by the Schrödinger equation
\begin{equation*}
    i\hbar\frac{d}{dt}\ket{\psi} = H\ket{\psi}
\end{equation*}
In this equation, $\hbar$ is a physical constant known as Planck's constant whose value
must be experimentally determined. The exact value is not important to us. In
practice, it is common to absorb the factor $\hbar$ into $H$, effectively setting $\hbar = 1$. $H$
is a ﬁxed Hermitian operator known as the Hamiltonian of the closed system\footnote{Earlier, we spoke about applying a unitary operator to a system. Doesn't this contradict the fact that postulate 2 only holds for closed systems? Yes!
We should consider the experimentation set-up as a part of our system if we want to use the hamiltonian to describe it. But, the unitary operator is a good enough approximation
that we can push this nuance under the rug.}.

\subsection{Quantum measurement} \label{post3}
Even though the internal evolution of a quantum system can be worked out, there are times when we need to measure the quantum system, i.e. interact it with 
the experimental set-up which leads to the system not being closed anymore. This postulate addresses this development of the system. 

\textbf{Postulate 3} : Quantum measurements are described by a collection $\{M_m\}$ of
measurement operators. These are operators acting on the state space of the
system being measured. The index $m$ refers to the measurement outcomes that
may occur in the experiment. If the state of the quantum system is $\ket{psi}$
immediately before the measurement then the probability that result $m$ occurs is given by, 
\begin{equation*}
    p(m) = \bra{\psi}M_{m}^{\dag}M_{m}\ket{\psi}
\end{equation*}
and the state of the system after the measurement is
\begin{equation*}
    \frac{M_{m}\ket{\psi}}{\sqrt{\bra{\psi}M_{m}^{\dag}M_{m}\ket{\psi}}}
\end{equation*}
The measurement operators satisfy the completeness equation,
\begin{equation*}
    \sum_{m}M_{m}^{\dag}M_{m} = I
\end{equation*}
The completeness equation expresses the fact that probabilities sum to one:
\begin{equation*}
    1 = \sum_{m}p(m) = \sum_{m}\bra{\psi}M_{m}^{\dag}M_{m}\ket{\psi}
\end{equation*}

A simple but important example of a measurement is the measurement of a qubit in
the computational basis. This is a measurement on a single qubit with two outcomes
deﬁned by the two measurement operators $M_0 = \ket{0}\bra{0}$, $M_1 = \ket{1}\bra{1}$. The probability of measured 
outcomes can be verified using this postulate.

An important application of Postulate 3 is to the problem of distinguishing quantum
states. In the classical world, distinct states of an object are usually distinguishable, at
least in principle. For example, we can always identify whether a coin has landed heads or
tails. An important result follows from postulate 3 that only only \textit{orthogonal states} can be distinguished.

\subsection{Composite systems}
\textbf{Postulate 4}: The state space of a composite physical system is the tensor product
of the state spaces of the component physical systems. Moreover, if we have
systems numbered $1$ through $n$, and system number $i$ is prepared in the state
$\ket{\psi_i}$, then the joint state of the total system is $\ket{\psi_1} \otimes \ket{\psi_2} \otimes \cdots \otimes \ket{\psi_n}$.

Further details about density operators, EPR can be found in \cite{b2}.

\section{Quantum circuits} \label{gates}
In this section, we will examine some more circuits and gates, theorems that help us to construct more complicated gates 
from simple building blocks.

The Pauli matrices give rise to three useful classes of unitary matrices when they are
exponentiated, the rotation operators about the $\hat{x}, \hat{y}$, and $\hat{z}$ axes, deﬁned by the equations:
\begin{align*}
    R_{x}(\theta) \equiv e^{\frac{-i\theta X}{2}} &= cos\frac{\theta}{2}I - isin\frac{\theta}{2}X \\
    R_{y}(\theta) \equiv e^{\frac{-i\theta Y}{2}} &= cos\frac{\theta}{2}I - isin\frac{\theta}{2}Y \\
    R_{z}(\theta) \equiv e^{\frac{-i\theta Z}{2}} &= cos\frac{\theta}{2}I - isin\frac{\theta}{2}Z  
\end{align*}
\textit{Theorem} : (\textbf{Z-Y decomposition for a single qubit}) Suppose $U$ is a unitary
operation on a single qubit. Then there exist real numbers $\alpha, \beta, \gamma$ and $\delta$ such that
\begin{equation*}
    U = e^{i\alpha}R_{z}(\beta)R_{y}(\gamma)R_{x}(\delta)
\end{equation*}

\subsection{Controlled operation}
Suppose $U$ is an arbitrary single qubit unitary operation. A controlled-$U$ operation is a two qubit operation, again with a control and a target qubit. If the control
qubit is set then $U$ is applied to the target qubit, otherwise the target qubit is left alone; that is, 
\begin{equation*}
    \ket{c}\ket{t} \to \ket{c}U^{c}\ket{t}
\end{equation*}
where $\ket{c}, \ket{t}$ are computational basis states. The general operation is then done via tensor products.
The controlled-U operation is represented by the circuit shown in figure \ref{controlled-u}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/controlled-u.png}}
\caption{Controlled-U operation. The top line is the control qubit, and the bottom line is the target qubit. If the
control qubit is set then U is applied to the target, otherwise it is left alone}
\label{controlled-u}
\end{figure}

Now, our goal is to construct a generalised controlled-U operation. In order to do this, the following theorem is useful : 

\textbf{Theorem} : Suppose $U$ is a unitary gate on a single qubit. Then there exist unitary
operators $A, B, C$ on a single qubit such that $ABC = I$ and $U = e^{i\alpha} AXBXC$,
where $\alpha$ is some overall phase factor.

First, let us consider the controlled phase shift operation. This operation does, $\ket{00} \to \ket{00}, \ket{01} \to \ket{01}, 
\ket{10} \to e^{i\alpha}\ket{10}, \ket{11} \to e^{i\alpha}\ket{11}$. The equivalent circuits for the same are given in figure \ref{controlled-phase-shift}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/controlled-phase-shift.png}}
\caption{Controlled phase shift gate and an equivalent circuit for two qubits}
\label{controlled-phase-shift}
\end{figure}

Now, we have enough to implement a controlled phase operation. The circuit for the same utilizes black boxes for $A, B, C$, and the \verb|CNOT| gate, along with 
controlled phase shift. The circuit is shown in figure \ref{u-exp}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/u-exp.png}}
\caption{Circuit implementing the controlled-U operation for single qubit U}
\label{u-exp}
\end{figure}

\subsection{Multi-qubit controlled operations}

A well-known example of a multi-qubit control circuit is known as the \textit{toffoli gate}. 
This gate acts on the target qubit only if both the control qubits are in the $\ket{1}$ state. Hence, it is an extended 
\verb|CNOT| gate in some sense. 
The circuit for the same is shown in figure \ref{toffoli}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/toffoli.png}}
\caption{Toffoli gate}
\label{toffoli}
\end{figure}

We would further like to generalise this idea just as we did for a single control qubit. So, we introduce the generalised controlled-U gate, with 
$n$ control qubits and $k$ target qubits. This operator acts on a system of qubits as, 
\begin{equation*}
    C^{n}(U)\ket{x_{1}x_{2}{}_{\cdots}x_{n}}\ket{\psi} = \ket{x_{1}x_{2}{}_{\cdots}x_{n}}U^{x_{1}x_{2}{}_{\cdots}x_{n}}\ket{\psi}
\end{equation*}
where $x_{1}x_{2}{}_{\cdots}x_{n}$ in the exponent of $U$ means the product of the bits $x_{1}, x_{2},{}_{\cdots}, x_{n}$

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/gen_u_example.png}}
\caption{Sample circuit representation for the $C^{n}(U)$ operation, where $U$ is a unitary operator on $k$ qubits, for
$n = 4$ and $k = 3$.}
\label{gen-u-ex}
\end{figure}

Now, our task is to construct this generalised controlled-$U$ gate using the gates we know how to construct.
As it turns out, we can construct we can construct this gate using the single control qubit controlled-$U$ gate, and the toffoli gates. 
The circuit for the same has been shown in figure \ref{u-construct}.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.5]{Images/u-construct.png}}
\caption{Network implementing the $C^{n}(U)$ operation, for the case $n = 5$.}
\label{u-construct}
\end{figure}

\subsection{Circuit Identities}
Here are some important circuit identities. Let subscripts denote which qubit an operator acts on, and let 
$C$ be a \verb|CNOT| with qubit $1$ the control qubit and qubit $2$ the target qubit. 
\begin{align*}
    CX_{1}C &= X_{1}X_{2} \\ 
    CY_{1}C &= Y_{1}X_{2} \\ 
    CZ_{1}C &= Z_{1} \\ 
    CX_{2}C &= X_{2} \\ 
    CY_{2}C &= Z_{1}Y_{2} \\
    CZ_{2}C &= Z_{1}Z_{2} \\
    R_{z,1}(\theta)C &= CR_{z,1}(\theta) \\ 
    R_{x,2}(\theta)C &= CR_{x,2}(\theta)
\end{align*} 

\subsection{Measurement \& Universal circuits}

There are really only two things worth knowing here : 
\begin{enumerate}
    \item The ﬁrst principle is that classically conditioned operations 
    can be replaced by quantum conditioned operations
    \item \textbf{Principle of deferred measurement}: Measurements can always be moved from
    an intermediate stage of a quantum circuit to the end of the circuit; if the
    measurement results are used at any stage of the circuit then the classically
    controlled operations can be replaced by conditional quantum operations.
\end{enumerate}

Now, let's talk about universal quantum circuits. In classical circuits, \verb|NOT|, \verb|AND| and \verb|OR| are 
enough to describe any boolean function. Similarly for quantum circuits, there are three constructions we can make : 
\begin{enumerate}
    \item The ﬁrst construction shows that an arbitrary unitary operator may be expressed ex-
    actly as a product of unitary operators that each acts non-trivially only on a subspace
    spanned by two computational basis states.
    \item The second construction combines the ﬁrst
    construction with the results of the previous section to show that an arbitrary unitary
    operator may be expressed exactly using single qubit and \verb|CNOT| gates.
    \item The third construction combines the second construction with a proof that single qubit operation may
    be approximated to arbitrary accuracy using the Hadamard, phase, and $\pi/8$ gates.
\end{enumerate}

For more on universal quantum gates, one can refer \cite{b2}. 

\section{Quantum Fourier Transform}
The quantum Fourier transform is an efﬁcient quantum algorithm for performing a Fourier transform of quantum mechanical amplitudes.
This idea is useful in algorithms like Grover's search. Let's explore the discrete fourier transform. Let $\ket{0}, \ket{1}, \cdots, \ket{N-1}$
be an orthonormal basis. Let the scalar coefficients corresponding to these basis states be $x_{1}, x_{2}, \cdots, x_{N-1}$. Then, the transformation is 
defined by; 
\begin{equation*}
    y_{k} \equiv \frac{1}{\sqrt{N}}\sum_{j=0}^{N-1}x_{j}e^{\frac{2\pi ijk}{N}}
\end{equation*}
\begin{equation*}
    \ket{j} \to \frac{1}{\sqrt{N}}\sum_{k=0}{N-1}e^{\frac{2\pi ijk}{N}}\ket{k}
\end{equation*}
Equivalently, an arbitrary state 
\begin{equation*}
    \sum_{j=0}^{N-1}x_{j}\ket{j} \xrightarrow{U} \sum_{k=0}^{N-1}y_{k}\ket{k}
\end{equation*}
where $U$ is a unitary operator. \\
In the following, we take $N = 2^n$ , where $n$ is some integer, and the basis $\ket{0}, \ket{1}, \cdots, \ket{2^n-1}$ is the 
computational basis for an $n$ qubit quantum computer. It is helpful to write the state 
$\ket{j}$ using the binary representation $j = j_{1}j_{2}{}_{\cdots}j_{n}$. 
More formally, $j = j_{1}2^{n-1} + j_{2}2^{n-2} + \cdots + j_{n}2^{0}$. It is also convenient to adopt the notation 
$0.j_{l}j_{l+1}{}_{\cdots}j_{m}$ to represent 
the binary fraction $j_{l}/2 + j_{l+1}/4 + \cdots + j_{m}/2^{m-l+1}$. 

With a little algebra the quantum Fourier transform can be given the following useful
\textit{product representation}:
\begin{equation*}
    \ket{j_{1}, {}_{\cdots}, j_{n}} \to \frac{(\ket{0} + e^{2\pi i0.j_{n}}\ket{1})\cdots(\ket{0} + e^{2\pi i0.j_{1}{}_{\cdots}j_{n-1}j_{n}}\ket{1})}{2^{n/2}}
\end{equation*}
This product representation is so useful that you may even wish to consider this to be the
deﬁnition of the quantum Fourier transform. This allows us to construct an efﬁcient quantum circuit computing the Fourier transform, a
proof that the quantum Fourier transform is unitary, and provides insight into algorithms
based upon the quantum Fourier transform. \\ 
Let the gate $R_k$ denotes the unitary transformation; 
\begin{equation*}
    R_k \equiv 
    \begin{bmatrix}
    1 & 0 \\ 
    0 & e^{2\pi i/2^k}
    \end{bmatrix}
\end{equation*}
Given this, the quantum fourier transform circuit, i.e. an efficient algorithm for the same is shown in figure \ref{qft}.
\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.25]{Images/qft.png}}
\caption{Efﬁcient circuit for the quantum Fourier transform. This circuit is easily derived from the \textit{product
representation} for the quantum Fourier transform. Not shown are swap gates at the end of the circuit which
reverse the order of the qubits, or normalization factors of $1/\sqrt{2}$ in the output.}
\label{qft}
\end{figure}

\subsection{Phase estimation}
The Fourier transform is the key to a general procedure known as \textit{phase estimation},
which in turn is the key for many quantum algorithms. Suppose a unitary operator $U$
has an eigenvector $\ket{u}$ with eigenvalue $e^{2\pi i\phi}$, where the value of $\ket{\phi}$ is unknown. The goal
of the phase estimation algorithm is to estimate $\ket{\phi}$. To perform the estimation we assume
that we have available black boxes (sometimes known as oracles) capable of preparing the $j$
state $\ket{u}$ and performing the controlled-$U^{2^j}$ operation, for suitable non-negative integers
$j$.

The quantum phase estimation procedure uses two registers. The ﬁrst register contains
$t$ qubits initially in the state $\ket{0}$. How we choose $t$ depends on two things: the number
of digits of accuracy we wish to have in our estimate for $\phi$, and with what probability
we wish the phase estimation procedure to be successful. 

The second register begins in the state $\ket{u}$, and contains as many qubits as is necessary
to store $\ket{u}$. Phase estimation is performed in two stages. First, we apply the circuit shown
in Figure \ref{phase-1}. 
\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.25]{Images/phase-1.png}}
\caption{The ﬁrst stage of the phase estimation procedure. Normalization factors of $1/\sqrt{2}$ have been omitted, on
the right.}
\label{phase-1}
\end{figure}
The second stage of phase estimation, shown in figure \ref{phase-2}, is to apply the inverse quantum Fourier transform
on the ﬁrst register. This is obtained by reversing the circuit for the quantum Fourier
transform in the previous section, and can be done in $\Omega(t^2)$ steps. The
third and ﬁnal stage of phase estimation is to read out the state of the ﬁrst register by
doing a measurement in the computational basis.
\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.25]{Images/phase-2.png}}
\caption{Schematic of the overall phase estimation procedure. The top $t$ qubits (the '/' denotes a bundle of
wires, as usual) are the ﬁrst register, and the bottom qubits are the second register, numbering as many as required
to perform $U$. The state u is an eigenstate of $U$ with eigenvalue $e^{2i\pi\phi}$. The output of the measurement is an
approximation to $\phi$ accurate to $t - \ceil*{log(2 + \frac{1}{2\epsilon})}$ bits, with probability of success at least $1 - \epsilon$.}
\label{phase-2}
\end{figure}
Summarizing, the phase estimation algorithm allows one to estimate the phase $\phi$ of an
eigenvalue of a unitary operator $U$, given the corresponding eigenvector $\ket{u}$. An essential
feature at the heart of this procedure is the ability of the inverse Fourier transform to
perform the transformation
\begin{equation*}
    \frac{1}{2^{t/2}}\sum_{j=0}^{2^t-1}e^{2\pi i\phi j}\ket{j}\ket{u} \to \ket{\tilde{\phi}}\ket{u}
\end{equation*}
where $\tilde{\phi}$ denotes a state which is a good estimator for $\phi$ when measured.

\subsection{Application : Order finding}
As it turns out the problems of order finding and factoring are equivalent, that is, the problem of 
factoring can be expressed as an order finding problem. So, if we solve order finding, we get factoring for free.
Now, what is the order finding problem? For positive integers $x$ and $N$, $x < N$, with no common factors, the order of $x$ modulo $N$
is deﬁned to be the least positive integer, $r$, such that $x^r \equiv 1$(mod $N$).

The quantum algorithm for order-ﬁnding is just the phase estimation algorithm applied
to the unitary operator
\begin{equation*}
    U\ket{y} = \ket{xy(\text{mod N})}
\end{equation*}
with $y \in \{0, 1\}^L$. (Note that here and below, when $N \leq y \leq 2^L - 1$, we use the
convention that $xy$(mod N) is just $y$ again. That is, $U$ only acts non-trivially when
$0 \leq y \leq N - 1$). A simple calculation shows that the states deﬁned by
\begin{equation*}
    \ket{u_s} \equiv \frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{-\frac{2\pi isk}{r}\ket{x^k \text{ mod N}}}
\end{equation*}
for integer $0 \leq s \leq r - 1$ are eigenstates of $U$ , since
\begin{align*}
    U\ket{u_s} &= \frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{-\frac{2\pi isk}{r}\ket{x^{k+1} \text{ mod N}}} \\ 
    &= e^{\frac{2\pi is}{r}}\ket{u_s}
\end{align*}
Using the phase estimation procedure allows us to obtain, with high accuracy, the corresponding 
eigenvalues $exp(2\pi is/r)$, from which we can obtain the order $r$ with a little bit more work.

There are two important requirements for us to be able to use the phase estimation
procedure: we must have efﬁcient procedures to implement a controlled-$U^{2^j}$ operation
for any integer $j$, and we must be able to efﬁciently prepare an eigenstate $\ket{u_s}$ with a non-trivial 
eigenvalue, or at least a superposition of such eigenstates. The ﬁrst requirement
is satisﬁed by using a procedure known as modular exponentiation, with which we
can implement the entire sequence of controlled-$U^{2^j}$ operations applied by the phase
estimation procedure using $O(L^3)$ gates. \\ 
The second requirement is a bit trickier. preparing $\ket{u_s}$ requires that we know $r$, so
this is out of the question. Fortunately, there is a clever observation which allows us to
circumvent the problem of preparing $\ket{u_s}$, which is that : 
\begin{equation*}
    \frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\ket{u_s} = \ket{1}
\end{equation*}
Hence, preparing $\ket{1}$ in the second register suffices, which is trivial. Hence, the circuit is complete and is shown in 
figure \ref{order}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.25]{Images/order.png}}
\caption{Quantum circuit for the order-ﬁnding algorithm.}
\label{order}
\end{figure}

Even after doing this, we are not done yet. The measurement will give us an estimate of $s/r$. We need to determine the value of $r$ from this. This can be done using the continued fractions 
expansion since we know the number of bits upto which these numbers upto a good accuracy. The process of continued fractions finally yields us $r$.
The algorithm has been summarised in figure \ref{order-summ}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/order-summary.png}}
\caption{Algorithm for the order-finding problem}
\label{order-summ}
\end{figure}

\subsection{Application : Factoring}
The factoring problem is given a natural number $N \in \N$, to return a non-trivial factor of $N$, that is, other than 1 and $N$ itself.
As described earlier, we will simply reduce this problem into order-finding. This is how we do it. 
\begin{enumerate}
    \item If $N$ is even, return the factor $2$.
    \item Determine whether $N = a^b$ for integers $a \geq 1$ and $b \geq 2$, and if so
    return the factor $a$ (classical algorithm described in \cite{b6}).
    \item Randomly choose $x$ in the range $1$ to $N-1$. If $gcd(x, N) > 1$ then return
    the factor $gcd(x, N)$.
    \item Use the order-ﬁnding subroutine to ﬁnd the order $r$ of $x$ modulo $N$ .
    \item If $r$ is even and $x^{r/2} \neq - 1(\text{mod N})$ then compute $gcd(x^{r/2} - 1, N)$ and
    $gcd(x^{r/2} + 1, N)$, and test to see if one of these is a non-trivial factor,
    returning that factor if so. Otherwise, the algorithm fails.
\end{enumerate}
That is it. 

\section{Quantum Search Algorithms}

This section deals with searching for solutions through a set of some inputs. The algorithm we explore here is called the \textit{grover search algorithm}. But first, 
how do we know which input is a solution? For this, we need something called an \textit{oracle}

\subsection{Oracle}
Suppose we wish to search through a search space of $N$ elements. Rather than search the
elements directly, we concentrate on the index to those elements, which is just a number
in the range $0$ to $N - 1$. For convenience we assume $N = 2^n$, so the index can be stored
in $n$ bits, and that the search problem has exactly $M$ solutions, with $1 \leq M \leq N$ . A
particular instance of the search problem can conveniently be represented by a function
$f$ , which takes as input an integer $x$, in the range $0$ to $N - 1$. By deﬁnition, $f(x) = 1$ if
$x$ is a solution to the search problem, and $f(x) = 0$ if $x$ is not a solution to the search
problem.

Given this framework, a quantum oracle is just a black box. It is a unitary operator whose action is described as : 
\begin{equation*}
    \ket{x}\ket{q} \xrightarrow{O} \ket{x}\ket{q \oplus f(x)}
\end{equation*}
We can check whether $x$ is a solution to our search problem by preparing $\ket{x}\ket{0}$, applying the oracle,
and checking to see if the oracle qubit has been ﬂipped to $\ket{1}$.
In the quantum search algorithm it is useful to apply the oracle with the oracle qubit
initially in the state $\frac{\ket{0}-\ket{1}}{\sqrt{2}}$, The action of the oracle is : 
\begin{equation*}
    \ket{0}\left(\frac{\ket{0} - \ket{1}}{\sqrt{2}}\right) \xrightarrow{O} (-1)^{f(x)}\ket{0}\left(\frac{\ket{0} - \ket{1}}{\sqrt{2}}\right)
\end{equation*}
Since the second qubit doesn't change here, it can be omitted : 
\begin{equation*}
    \ket{0} \xrightarrow{O} (-1)^{f(x)}\ket{0}
\end{equation*}
We say that the oracle marks the solutions to the search problem, by shifting the phase
of the solution. As it turns out, the grover search algorithm can find a solution in $O(\sqrt{N/M})$ time, where 
$N$ is the cardinality of the search space, $M$ is the number of solutions. 

\subsection{The procedure}
The algorithm proper makes use of a single n qubit register. The internal workings of the oracle, in-
cluding the possibility of it needing extra work qubits, are not important to the description
of the quantum search algorithm proper. The goal of the algorithm is to ﬁnd a solution
to the search problem, using the smallest possible number of applications of the oracle.

The algorithm begins with the computer in the state $\ket{0}^{\otimes n}$ . The Hadamard transform
is used to put the computer in the equal superposition state,
\begin{equation*}
    \ket{\psi} = \frac{1}{N^{1/2}}\sum_{x=0}^{N-1}\ket{x}
\end{equation*}
The quantum search algorithm then consists of repeated application of a quantum
subroutine, know as the Grover iteration or Grover operator, which we denote G. The
Grover iteration, whose quantum circuit is illustrated in Figure \ref{grover-it}, may be broken up
into four steps:
\begin{enumerate}
    \item Apply the oracle $O$.
    \item Apply the Hadamard transform $H^{\otimes n}$.
    \item Perform a conditional phase shift on the computer, with every computational basis
    state except $\ket{0}$ receiving a phase shift of $-1$,
    \begin{equation*}
        \ket{x} \to -(-1)^{\delta_{x0}}\ket{x}
    \end{equation*}
    \item Apply the Hadamard transform $H^{\otimes n}$.
\end{enumerate}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/grover-iteration.png}}
\caption{Circuit for the Grover iteration, G}
\label{grover-it}
\end{figure}

It is useful to note that the combined effect of steps 2, 3, and 4 is, 
\begin{equation*}
    H^{\otimes n}(2\ket{0}\bra{0}-I)H^{\otimes n} = 2\ket{\psi}\bra{\psi}-I
\end{equation*}
where $\ket{\psi}$ is the equally weighted superposition of states. Thus the Grover iteration,
$G$, may be written $G = (2\ket{\psi}\bra{\psi} - I)O$. 

\subsection{Geometric visualisation}
The Grover iteration can be regarded as a rotation in the two-dimensional
space spanned by the starting vector $\ket{\psi}$ and the state consisting of a uniform superposition
of solutions to the search problem. We adopt the convention that, $\sum_{x}^{'}$, 
indicates a sum over all $x$ which are solutions to the search problem, and $\sum_{x}^{''}$
indicates a sum over all $x$ which are not solutions to the search problem. Deﬁne normalized
states, 
\begin{equation*}
    \ket{\alpha} \equiv \frac{1}{\sqrt{N-M}}\sum_{x}^{''}\ket{x}
\end{equation*}
\begin{equation*}
    \ket{\beta} \equiv \frac{1}{\sqrt{M}}\sum_{x}^{'}\ket{x}
\end{equation*}
Simple algebra shows that the initial state $\ket{\psi}$ may be re-expressed as, 
\begin{equation*}
    \ket{\psi} = \sqrt{\frac{N-M}{N}}\ket{\alpha} + \sqrt{\frac{M}{N}}\ket{\beta}
\end{equation*}
so the initial state of the quantum computer is in the space spanned by $\ket{\alpha}$, $\ket{\beta}$.

The effect of G can be understood in a beautiful way by realizing that the oracle
operation $O$ performs a reﬂection about the vector $\ket{\alpha}$ in the plane deﬁned by $\ket{\alpha}$ and
$\ket{\beta}$. Similarly, $2\ket{\psi}\bra{\psi} - I$ also performs a
reﬂection in the plane deﬁned by $\ket{\alpha}$ and $\ket{\beta}$, about the vector $\ket{\psi}$. And the product of
two reﬂections is a rotation. Let $cos \frac{\theta}{2} = (N - M )/N$ ,
so that $\ket{\psi} = cos \frac{\theta}{2}\ket{\alpha} + sin \frac{\theta}{2}\ket{\beta}$. As Figure \ref{grover-vis} shows, the two reﬂections which
comprise $G$ take $\ket{\psi}$ to, 
\begin{equation*}
    G\ket{\psi} = cos \frac{3\theta}{2} \ket{\alpha} + sin \frac{3\theta}{2} \ket{\beta}
\end{equation*}

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/grover-vis.png}}
\caption{Grover's iteration visualised}
\label{grover-vis}
\end{figure}

\subsection{Performance}
Now, the question boils down to how many grover's iterations/rotations are required to convert $\ket{\psi}$ to $\ket{\beta}$? As it turns 
out the upper bound on the number of rotations $R$ required after some calculations is given by, 
\begin{equation*}
    R \leq \left[\frac{\pi}{4}\sqrt{\frac{N}{M}}\right]
\end{equation*}
Finally, the algorithm is summarised in Figure \ref{grover-algo}. 

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/grover-algo.png}}
\caption{Grover's Algorithm}
\label{grover-algo}
\end{figure}

\section{Quantum Machine Learning}
In this section, we will primarily focused on the studies described in \cite{b1}, \cite{b5}, \cite{b7} (\cite{b8} is a good resource on how to read papers). 
Coming up with machine learning algorithms using quantum computation is particularly difficult since the algorithm has to perform better than the classical version, 
is often unintuitive.

\subsection{k-nearest neighbour methods}
This is a standard algorithm for unsupervised learning. The procedure of the algorithm relies upon clustering the data-points into some groups
depending on the distances of the points from the centroids of the groups. This is illustrated in Figure \ref{knn}. This is one of the many 
machine learning methods that rely on the notion of a \textit{distance metric}. There are a lot of distance metrics available, but measuring 
the inner product between two points or states is a good start since the notion of overlap is natural in the field of quantum mechanics.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/knn.png}}
\caption{a: Illustration of the
kNN method of pattern classification. The new vector (black cross) gets assigned to the class that the
majority of its $k$ closest neighbours have (in this case
it would be the orange circle shape). b: A variation
is the nearest-centroid method in which the closest
mean vector of a class of vectors defines the classification of a new input. This can be understood as a
$k$-nearest neighbour method with preprocessed data
and $k$ = 1.}
\label{knn}
\end{figure}

There is a neat method to find the overlap of two states known as the \textit{swap test}. 
Given a quantum state $\ket{a,b,0_{anc}}$ containing the two wavefunctions as well
as an ancilla register initially set to 0, a Hadamard transformation sets the ancilla into a superposition
$1/\sqrt{2}(\ket{0} + \ket{1})$ followed by a controlled SWAP-gate on a and b which swaps the two states under the
condition that the ancilla is in state $\ket{1}$. A second Hadamard gate on the ancilla results in state
$\ket{\psi_{SW}} = \frac{1}{2}\ket{0}(\ket{a,b} + \ket{b,a}) + \frac{1}{2}\ket{1}(\ket{a,b}-\ket{b,a})$ for
which the probability of measuring the ground state is given by
\begin{equation*}
    P(\ket{0_{anc}}) = \frac{1}{2}(1 + \innerproduct{a}{b}^2)
\end{equation*}
the distance between two real-valued n-dimensional vectors $a$ and $b$ is computed through a quantum measurement.
The following states are prepared : 
\begin{align*}
    \ket{\psi} &= \frac{1}{\sqrt{2}}(\ket{0,a} + \ket{1,b}) \\ 
    \ket{\phi} &= \frac{1}{\sqrt{Z}}(\|a\|\ket{0} - \|b\|\ket{1}) \\
    \Rightarrow \frac{1}{4}Z\|\innerproduct{\phi}{\psi}\|^2 &= \|a-b\|^2
\end{align*}
where, $Z = \|a\|^2 + \|b\|^2$. Hence, we can compute the distance between two vectors using this method.
Quantum clustering algorithms work along similar lines so will not be covered here.

\subsection{Quantum pattern recognition}
The aim of this model is to measure the hamming distance betwen two binary quantum states. 
Say we are given two binary strings as $\ket{a_{1}a_{2}{}_{\cdots}a_{n}}$ and $\ket{b_{1}b_{2}{}_{\cdots}b_{n}}$ with entries 
$a_i, b_i \in \{0, 1\}$. Now construct, 
\begin{equation*}
    \ket{\psi} = \ket{a_{1}a_{2}{}_{\cdots}a_{n},b_{1}b_{2}{}_{\cdots}b_{n}} \otimes \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})
\end{equation*}
Now, denote 
\begin{equation*}
    \bar{d_k} = 
    \begin{cases}
        0, \text{if } \ket{a_k} = \ket{b_k} \\ 
        1, \text{else}
    \end{cases}
\end{equation*}
Now, over-write qubits of $b$ using \verb|XOR| gate. 
\begin{equation*}
    \ket{\psi^{'}} = \ket{a_{1}{}_{\cdots}a_{n}, \bar{d_1}, {}_{\cdots}, \bar{d_n}} \otimes \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})
\end{equation*}
To write the total Hamming distance $\bar{d_H}(\bar{a}, \bar{b})$, we use the unitary operator $U = exp(-i\frac{\pi}{2n}H)$
with $H = 1 \otimes \sum_{k}(\frac{1}{2}(\sigma_z + 1))_{d_k} \otimes \sigma_z$. Note that this adds a negative sign to the ancilla. 
Now, apply $H_{anc} = 1 \otimes 1 \otimes H$ consequently resulting in, 
\begin{align*}
    \ket{\psi^{''}} &= cos[\frac{\pi}{2n}\bar{d_H}(\bar{a}, \bar{b})]\ket{a_{1}{}_{\cdots}a_{n}, \bar{d_1}, {}_{\cdots}, \bar{d_n}, 0}\\ 
    &+ sin[\frac{\pi}{2n}\bar{d_H}(\bar{a}, \bar{b})]\ket{a_{1}{}_{\cdots}a_{n}, \bar{d_1}, {}_{\cdots}, \bar{d_n}, 1}
\end{align*}
Measuring the ancilla in $\ket{0}$ leads to a state in whichthe amplitude scales with the Hamming distance
between $a$ and $b$.

\subsection{Decision Trees}
Decision trees (Figure \ref{tree}) are important models which deal with functions that split dataset into ``most-organised'' sub-datasets. This can 
be measured in terms of Shannon's entropy.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/dec-tree.png}}
\caption{A simple example of a decision tree for
the classification of emails. The geometric shapes
symbolise feature vectors from different classes that
are devided according to decision functions along the
tree structure}
\label{tree}
\end{figure}
However, the quantum analogue of this is not very clear. So, we won't go into further depth here.

\subsection{Hidden quantum Markov Models}
Hidden Markov models (Figure \ref{markov}) are another important method of machine learning that have been investigated from the perspective of quantum information.
In a (first order discrete and static) Markov model, a system has a countable set of states
$S = \{s_m\}_{m=1,{}_{\cdots},M}$ and the transition between these states are governed by a stochastic process in such
a way that given a set of transition probabilities $\{a_{ml}\}_{m,l=1,\cdots,M}$ , the system's state at time $t + 1$ only depends on the previous state at time $t$
In a hidden markov model, the state of the system is only accessible through observations at time $t(o_t)$ that can take one set of symbols, and an observation again has a
certain probability to be invoked by a specific state.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/markov.png}}
\caption{A hidden Markov model
is a stochastic process of state transitions. In this
sketch, the three states $s_1 , s_2 , s_3$ are connected with
lines symbolising transition probabilities. A deterministic realisation is a sequence of states, here the
transition $s_1 \to s_2 \to s_1$ that give rise to observations $o_{12} \to o_4  \to o_8$ . A task for hidden Markov models
is to guess the most likely state sequence given an observation sequence.}
\label{markov}
\end{figure}

The state of a system is given by a density matrix $\rho$ and transitions between
states are governed by completely positive trace-nonincreasing superoperators $A^i$ acting on these matrices.
These operations can always be represented by a set of Kraus operators $\{K_{1}^{i}, {}_{\cdots}, K_{q}^{i}\}$
fulfilling the probability conservation condition $\sum_{q} K_{q}^{i\dag}K_{q}^{i} \leq 1$, (don't know what Kraus operators are? Just think of them as operators for now)
\begin{equation*}
    \rho^{'} = A^{i}\rho = \sum_{q} K_{q}^{i\dag}\rho K_{q}^{i}
\end{equation*}
The probability of obtaining state $\rho_s = P(\rho_s)^{-1}A^{s}\rho$ is given by
\begin{equation*}
    P(\rho_s) = tr[A^{s}\rho]
\end{equation*}

\section{Quantum GANs (Literature Review)}

\subsection{Classical GANs}
First, let's explore what classical GANs are. We suppose that the real-world data comes
from some fixed distribution $p_{R}(x)$, generated by some process $R$. Classical GANs are based on training two functions, a generator(G) and a discriminator(D). 
$G$ transforms this noise source into data samples $x = G(\bar{\theta_{G}} , z)$, creating the generator distribution $p_{G}(x)$.
In the ideal case of a perfectly trained generator $G$, the discriminator would not be able to decide whether a given
sample $x$ came from $p_{G}(x)$ or from $p_{R}(x)$. Therefore, the task of training $G$ corresponds to the task of maximizing
the probability that $D$ misclassifies a generated sample as an element of the real data. On the other hand, D's goal is
to discriminate between these two classes, outputting a binary random variable. Training D thus corresponds to
maximizing the probability of successfully classifying real data, while minimizing the probability of misclassifying
fake data.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/gan1.png}}
\caption{The figure shows a high-level overview of classical and quantum GANs}
\label{gan1}
\end{figure}

\subsection{Quantum GANs}

For the quantum case, suppose we are given a data source R which, given a label
$\ket{\lambda}$, outputs a density matrix $\rho_{\lambda}^R$ into a register containing n subsystems, i.e.,
\begin{equation*}
    R(\ket{\lambda}) = \rho_{\lambda}^R
\end{equation*}

The general aim of training a GAN is to find a generator
$G$ which mimics the real data source $R$. The generator takes as input the label $\ket{\lambda}$ and an additional state (noise)
$\ket{z}$, and produces a quantum state as a density matrix. Moreover, the gates of the ciruit of G are parametrised by a vector $\vec{\theta_{G}}$
\begin{equation*}
    G(\vec{\theta_G}, \ket{\lambda, z}) = \rho_{\lambda}^G(\vec{\theta_G}, z)
\end{equation*}
Why do we use an extra parameter $z$?
\begin{enumerate}
    \item It can be seen as a source of unstructured noise which provides entropy within the generated data. So instead of just getting one output, you get mutliple outputs for the same label.
    \item It can be seen as a control for the generator, by
    tuning $\ket{z}$, we can transform the output state prepared by
    the generator, varying properties of the generated data
    which are not captured by the labels $\lambda$.
\end{enumerate}

Now, how do we train the functions $D$ and $G$?

The task of $D$ is to determine whether a given input state
was created by the real data source $R$ or the generator
$G$, whereas the task of $G$ is to fool $D$ into accepting its
output as being real. If the input was created by $R$, then
$D$ should output $\ket{real}$ in its output register, otherwise it
should output $\ket{fake}$.

The optimization objective for QuGAN training (based on the above discussion) can be formalised as the adversarial task : 
\begin{align*}
    \min_{\vec{\theta_G}} \max_{\vec{\theta_D}} \frac{1}{S} \sum_{\lambda = 1}^{S} Pr[(D(\vec{\theta_D}, \ket{\lambda}, R(\ket{\lambda})) = \ket{real}) \cap \\
    (D(\vec{\theta_D}, \ket{\lambda}, G(\vec{\theta_G},\ket{\lambda,z})) = \ket{fake})]
\end{align*}

The function $D$ takes three arguements, the parameter vector $\vec{\theta_D}$, and a label, image.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.3]{Images/qgan-scheme.png}}
\caption{The general structure of QuGANs}
\label{qgan-scheme}
\end{figure}

The real source $R$ or the parametrized generator 
$G(\vec{\theta_G})$ is applied on an initial state $\ket{0, \lambda, z}$ respectively defined on the Label $R|G$ (s-qubit system), Out
$R|G$ and Bath $R|G$ registers. The discriminator $D(\vec{\theta_D})$ uses
the information $\rho_{\lambda}^{R/G}$ from the source and an initial resource
state $\ket{0, 0, \lambda}$ defined on the Out $D$, Bath $D$ and Label $D$
registers. $D$ outputs its answer $\ket{real}$ or $\ket{fake}$ in the Out $D$
register. Now, let Z be defined as, 
\begin{equation*}
    Z \equiv \ket{real}\bra{real} - \ket{fake}\bra{fake}
\end{equation*}
The expectation value $\expectationvalue{Z}_{\text{Out D}}$ is proportional to
the probability that $D$ outputs $\ket{real}$. Now that we have a concrete output to our quantum circuit, we need to design a quantum loss function 
to update the parameters of the QuGAN.

\subsection{Quantum loss function}

The schematic of training a GAN is given in figure \ref{q-train}.

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.2]{Images/q-train.png}}
\caption{Algorithmic flow of the training of a QuGAN}
\label{q-train}
\end{figure}

For keeping this report breif, I will not go into the details of how the below expressions are derived. The reader can refer \cite{b7} for the same. 
The quantum cost function is given as, 
\begin{align*}
    V(\vec{\theta_D}, \vec{\theta_G}) &= \frac{1}{2} + \frac{1}{2S} \sum_{\lambda=1}^{S}(cos^2(\phi)tr(Z\rho_{\lambda}^{DR}(\theta_D)) \\ 
    & -sin^2(\phi) tr(Z\rho_{\lambda}^{DG}(\vec{\theta_D}, \vec{\theta_G}, z)))
\end{align*}
If the coin used in figure \ref{q-train} is fair, then we put $\phi = \frac{\pi}{4}$ and the optimisation problem reduces to, 
\begin{equation*}
    \min_{\vec{\theta_G}} \max_{\vec{\theta_D}} V(\vec{\theta_D}, \vec{\theta_G})
\end{equation*} 
Now that we have the cost function, the simplest thing to train our circuit is using gradient descent. So the update step at each iteration will be given as, 
\begin{align*}
    \vec{\theta_D^{k+1}} &= \vec{\theta_D^{k}} + \chi_{D}^k \grad_{\vec{\theta_D}} V(\vec{\theta_D^k}, \vec{\theta_G^k}) \\
    \vec{\theta_G^{k+1}} &= \vec{\theta_G^{k}} + \chi_{G}^k \grad_{\vec{\theta_G}} V(\vec{\theta_D^k}, \vec{\theta_G^k})
\end{align*}
where $\chi_D^k, \chi_G^k$ are learning rates for the model.

\subsection{Quantum Gradient}
Now, we need a quantum gradient circuit to compute the gradients required for gradient descent. Turns out, we can design a circuit for this as well!
As with the last section, we shall not derive the circuit here, but I'll show the schematic of the circuit. But first, some notation (fig \ref{u-decomp})

\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.4]{Images/unitary-decomp.png}}
\caption{This notation is used to signify the decomposition
of a unitary transformation in its elementary parametrized
gates.}
\label{u-decomp}
\end{figure}

A unitary transformation $U$ parametrized by a
vector $\vec{\theta}$ with $N$ components is denoted as,
\begin{equation*}
    U(\vec{\theta}) = U_N(\theta_N) {}_{\cdots} U_1{\theta_1}
\end{equation*}
Assuming each element is generated by a Hamiltonian
$h_j = h^{\dag}_j$ , an individual gate has the form,
\begin{equation*}
    U_{j}(\theta_j) = e^{-\frac{i}{2}\theta_j h_j}
\end{equation*}

Under this premise, the gradient calculating circuits are given by fig \ref{q-grad}
\begin{figure}[htbp]
\centerline{\includegraphics[scale = 0.4]{Images/q-grad.png}}
\caption{In (a), we show the general structure of quantum
gradients and the structure of quantum Hessians is shown in
(b).}
\label{q-grad}
\end{figure}

Hence, we can use these gradients in gradient descent calculations and we're done!

\section*{Conclusion and remarks}
I would like to thank the mentors of this project Siddhant Midha and Aditya Sriram for giving 
me the opportunity to study and appreciate this subject. I would suggest anyone who is interested in coding problems, ciphers, cryptography, quantum mechanics or just
mathematics to try out quantum computing. Personally, I enjoyed QC-QI eventhough I didn't particularly enjoy my first year quantum physics course. As far as resources are concerned, 
the reader can refer \cite{b3} (the project repo), or one can refer my personal \href{https://github.com/Ihsoj-Mahos/WiDS-QML}{repository} as well. 

\begin{thebibliography}{00}
\bibitem{b1} M. Schuld, I. Sinayskiy and F. Petruccione, ``An introduction to quantum machine learning,'' September 2014.
\bibitem{b2} M. Neilson and I. Chuang, ``Quantum Computing and Quantum Information, 10\textsuperscript{th} edition''
\bibitem{b3} S. Midha and A. Sriram ``Learning with Quantum Computers'' \href{https://github.com/siddhant-midha/WiDS-22-Learning-with-quantum-computers-}{\textit{Github repository}}, January 2023.
\bibitem{b4} C. H. Bennett, G. Brassard ``Quantum cryptography: Public key distribution and coin tossing'' March 2020.
\bibitem{b5} O. Simeone ``An Introduction to Quantum Machine Learning for Engineers'' May 2022.
\bibitem{b6} D. J. Bernstein. \href{http://cr.yp.to/papers/powers-19971106-retypeset20220326.pdf}{``Detecting perfect powers in essentially linear time"}. Mathematics of Computation 67 (1998), 1253-1283 Date: 1997.11.06. AMS version: 31pp.
\bibitem{b7} Pierre-Luc Dallaire-Demers, N. Killoran ``Quantum generative adversarial networks'' April 2018
\bibitem{b8} S. Keshav ``How to Read a Paper'', David R. Cheriton School of Computer Science, University of Waterloo
\end{thebibliography}
\vspace{12pt}

\end{document}
